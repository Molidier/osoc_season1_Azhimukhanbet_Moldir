
#include <verilated.h>
#include <verilated_vcd_c.h>
#include "Vlvl3_lab01.h"

// Verilator Example
// Generated by ChatGPT 2024

#include <stdlib.h>
#include <iostream>
#include <cstdlib>
#include <deque>
#include <memory>

#define MAX_SIM_TIME 300
#define VERIF_START_TIME 7
vluint64_t sim_time = 0;

// ALU input interface transaction item class
class AluInTx {
    public:
        uint16_t a;
        uint16_t b;
        uint8_t select;
        uint8_t mode;
        uint8_t carry_in;
};

// ALU output interface transaction item class
class AluOutTx {
    public:
        uint16_t alu_out;
        uint8_t carry_out;
        uint8_t compare;
};

// ALU scoreboard
class AluScb {
    private:
        std::deque<AluInTx*> in_q;

    public:
        void writeIn(AluInTx *tx){
            in_q.push_back(tx);
        }

        void writeOut(AluOutTx* tx){
            if(in_q.empty()){
                std::cout <<"Fatal Error in AluScb: empty AluInTx queue" << std::endl;
                exit(1);
            }

            AluInTx* in = in_q.front();
            in_q.pop_front();

            // Expected result calculation
            uint16_t expected_alu_out = 0;
            uint8_t expected_carry_out = 0;
            uint8_t expected_compare = (in->a == in->b) ? 1 : 0;

            if (in->mode == 1) { // Logic operations
                switch (in->select) {
                    case 0x0: expected_alu_out = ~in->a; break;
                    case 0x1: expected_alu_out = ~(in->a | in->b); break;
                    case 0x2: expected_alu_out = ~in->a & in->b; break;
                    case 0x3: expected_alu_out = 0; break;
                    case 0x4: expected_alu_out = ~(in->a & in->b); break;
                    case 0x5: expected_alu_out = ~in->b; break;
                    case 0x6: expected_alu_out = in->a ^ in->b; break;
                    case 0x7: expected_alu_out = in->a & ~in->b; break;
                    case 0x8: expected_alu_out = ~in->a | in->b; break;
                    case 0x9: expected_alu_out = ~(in->a ^ in->b); break;
                    case 0xA: expected_alu_out = in->b; break;
                    case 0xB: expected_alu_out = in->a & in->b; break;
                    case 0xC: expected_alu_out = 1; break;
                    case 0xD: expected_alu_out = in->a | ~in->b; break;
                    case 0xE: expected_alu_out = in->a | in->b; break;
                    case 0xF: expected_alu_out = in->a; break;
                    default: expected_alu_out = 0; break;
                }

            } else { // Arithmetic operations
                uint32_t extended_res = 0;
                //std:: cout<< "  Res : " << extended_res<< std:: endl;
                switch (in->select) {
                    case 0x0: extended_res = in->a; break;
                    case 0x1: extended_res = in->a | in->b; break;
                    case 0x2: extended_res = (in->a | (~in->b)) & 0xFFFF; break;
                    case 0x3: extended_res = -1; break;
                    case 0x4: extended_res = in->a | (in->a & ~in->b); break;
                    case 0x5: extended_res = ((in->a | in->b) + (in->a & ~in->b) + in->carry_in) & 0xFFFF; break;
                    case 0x6: extended_res = (in->a - in->b - 1) ; break;
                    case 0x7: extended_res = in->a & ~in->b; break;
                    case 0x8: extended_res = in->a + (in->a & in->b) + in->carry_in; break;
                    case 0x9: extended_res = in->a + in->b + in->carry_in; break;
                    case 0xA: extended_res = (in->a | (~in->b) & 0xFFFF) + (in->a & in->b) + in->carry_in; break;
                    case 0xB: extended_res = in->a & in->b; break;
                    case 0xC: extended_res = in->a + in->a + in->carry_in; break;
                    case 0xD: extended_res = (in->a | in->b) + in->a + in->carry_in; break;
                    case 0xE: extended_res = (in->a | (~in->b) & 0xFFFF) + in->a + in->carry_in; break;
                    case 0xF: extended_res = in->a + in->carry_in; break;
                    default: extended_res = 0; break;
                }
                expected_alu_out = extended_res & 0xFFFF;
                expected_carry_out = ((extended_res ) >> 16) & 0x1;
               // std:: cout<< "  Res : " << (extended_res >>16 ) & 0x1<< std:: endl;

            }

            // Compare expected and actual results
            if (expected_alu_out != tx->alu_out || expected_carry_out != tx->carry_out || expected_compare != tx->compare) {
                std::cout << "AluScb mismatch:" << std::endl;
                std::cout << "  Expected: a: " <<in->a << ", b: " << in->b << ", ALU Out = " << expected_alu_out << ", Carry Out = " << (int)expected_carry_out << ", Compare = " << (int)expected_compare << std::endl;
                std::cout << "  Actual: ALU Out = " << tx->alu_out << ", Carry Out = " << (int)tx->carry_out << ", Compare = " << (int)tx->compare << std::endl;
                std::cout << "  Simtime: " << sim_time << std::endl;
                std::cout << "  Select: " << (int)in->select << std::endl;
                std:: cout<< "  Mode: " <<(int) in->mode<< std:: endl;
                
                
            }

            delete in;
            delete tx;
        }
};

// ALU input interface driver
class AluInDrv {
    private:
        Vlvl3_lab01 *dut;
    public:
        AluInDrv(Vlvl3_lab01 *dut){
            this->dut = dut;
        }

        void drive(AluInTx *tx){
            if(tx != NULL){
                dut->carry_in = tx->carry_in;
                dut->a_in = tx->a;
                dut->b_in = tx->b;
                dut->select = tx->select;
                dut->mode = tx->mode;
                delete tx;
            }
        }
};

// ALU input interface monitor
class AluInMon {
    private:
        Vlvl3_lab01 *dut;
        AluScb *scb;
    public:
        AluInMon(Vlvl3_lab01 *dut, AluScb *scb){
            this->dut = dut;
            this->scb = scb;
        }

        void monitor(){
            AluInTx *tx = new AluInTx();
            tx->carry_in = dut->carry_in;
            tx->a = dut->a_in;
            tx->b = dut->b_in;
            tx->select = dut->select;
            tx->mode = dut->mode;
            scb->writeIn(tx);
        }
};

// ALU output interface monitor
class AluOutMon {
    private:
        Vlvl3_lab01 *dut;
        AluScb *scb;
    public:
        AluOutMon(Vlvl3_lab01 *dut, AluScb *scb){
            this->dut = dut;
            this->scb = scb;
        }

        void monitor(){
            AluOutTx *tx = new AluOutTx();
            tx->alu_out = dut->alu_out;
            tx->carry_out = dut->carry_out;
            tx->compare = dut->compare;
            scb->writeOut(tx);
        }
};

// ALU random transaction generator
AluInTx* rndAluInTx(){
    if(rand() % 5 == 0){
        AluInTx *tx = new AluInTx();
        tx->a = rand() % 11;
        tx->b = rand() % 11;
        tx->select = rand() % 16;
        tx->mode = rand() % 2;
        tx->carry_in = rand() % 2;
        return tx;
    } else {
        return NULL;
    }
}

int main(int argc, char** argv, char** env) {
    srand(time(NULL));
    Verilated::commandArgs(argc, argv);
    Vlvl3_lab01 *dut = new Vlvl3_lab01;

    Verilated::traceEverOn(true);
    VerilatedVcdC *m_trace = new VerilatedVcdC;
    dut->trace(m_trace, 5);
    m_trace->open("waveform.vcd");

    AluInTx *tx;

    AluScb *scb = new AluScb();
    AluInDrv *drv = new AluInDrv(dut);
    AluInMon *inMon = new AluInMon(dut, scb);
    AluOutMon *outMon = new AluOutMon(dut, scb);

    while (sim_time < MAX_SIM_TIME) {
        dut->eval();

        if(sim_time >= VERIF_START_TIME){
            // Monitor input interface
            inMon->monitor();

            // Drive random transactions
            tx = rndAluInTx();
            drv->drive(tx);

            // Monitor output interface
            outMon->monitor();
        }

        m_trace->dump(sim_time);
        sim_time++;
    }

    m_trace->close();
    delete dut;
    delete scb;
    delete drv;
    delete inMon;
    delete outMon;
    exit(EXIT_SUCCESS);
}
