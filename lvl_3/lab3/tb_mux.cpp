#include <verilated.h>
#include <verilated_vcd_c.h>
#include "Vmux.h"

// Verilator Example
// Generated by ChatGPT 2024

#include <stdlib.h>
#include <iostream>
#include <cstdlib>
#include <deque>
#include <memory>

#define MAX_SIM_TIME 300
#define VERIF_START_TIME 7
vluint64_t sim_time = 0;

// Mux input interface transaction item class
class MuxInTx {
    public:
        uint8_t mux_sel;
        uint8_t en;
        uint16_t d_in;
};

// Mux output interface transaction item class
class MuxOutTx {
    public:
        uint16_t d_out;
        uni
};

// Mux scoreboard
class MuxScb {
    private:
        std::deque<MuxInTx*> in_q;

    public:
        void writeIn(MuxInTx *tx){
            in_q.push_back(tx);
        }

        void writeOut(MuxOutTx* tx){
            if(in_q.empty()){
                std::cout <<"Fatal Error in MuxScb: empty MuxInTx queue" << std::endl;
                exit(1);
            }

            MuxInTx* in = in_q.front();
            in_q.pop_front();

            // Expected result calculation
            uint16_t expected_d_out = 0;

            if(in->en == 0){
                switch (in->mux_sel)
                {
                case 0x1: expected_d_out = 

                    break;
                
                default:
                    break;
                }
            }
            else{
                switch (in->en)
                {
                case /* constant-expression */:
                    /* code */
                    break;
                
                default:
                    break;
                }
            }

            

            // Compare expected and actual results
            if (expected_d_out != tx->d_out) {
                std::cout << "MuxScb mismatch:" << std::endl;
                std::cout << "  Expected: mux_sel: " << (int)in->mux_sel << ", en: " << (int)in->en << ", d_in: " << in->d_in << ", d_out = " << expected_d_out << std::endl;
                std::cout << "  Actual: d_out = " << tx->d_out << std::endl;
                std::cout << "  Simtime: " << sim_time << std::endl;
            }

            delete in;
            delete tx;
        }
};

// Mux input interface driver
class MuxInDrv {
    private:
        Vmux *dut;
    public:
        MuxInDrv(Vmux *dut){
            this->dut = dut;
        }

        void drive(MuxInTx *tx){
            if(tx != NULL){
                dut->mux_sel = tx->mux_sel;
                dut->en = tx->en;
                dut->d_in = tx->d_in;
                delete tx;
            }
        }
};

// Mux input interface monitor
class MuxInMon {
    private:
        Vmux *dut;
        MuxScb *scb;
    public:
        MuxInMon(Vmux *dut, MuxScb *scb){
            this->dut = dut;
            this->scb = scb;
        }

        void monitor(){
            MuxInTx *tx = new MuxInTx();
            tx->mux_sel = dut->mux_sel;
            tx->en = dut->en;
            tx->d_in = dut->d_in;
            scb->writeIn(tx);
        }
};

// Mux output interface monitor
class MuxOutMon {
    private:
        Vmux *dut;
        MuxScb *scb;
    public:
        MuxOutMon(Vmux *dut, MuxScb *scb){
            this->dut = dut;
            this->scb = scb;
        }

        void monitor(){
            MuxOutTx *tx = new MuxOutTx();
            tx->d_out = dut->d_out;
            scb->writeOut(tx);
        }
};

// Mux random transaction generator
MuxInTx* rndMuxInTx(){
    if(rand() % 5 == 0){
        MuxInTx *tx = new MuxInTx();
        tx->mux_sel = rand() % 8 + 1;
        tx->en = rand() % 256;
        tx->d_in = rand() % 65536;
        return tx;
    } else {
        return NULL;
    }
}

int main(int argc, char** argv, char** env) {
    srand(time(NULL));
    Verilated::commandArgs(argc, argv);
    Vmux *dut = new Vmux;

    Verilated::traceEverOn(true);
    VerilatedVcdC *m_trace = new VerilatedVcdC;
    dut->trace(m_trace, 5);
    m_trace->open("waveform.vcd");

    MuxInTx *tx;

    MuxScb *scb = new MuxScb();
    MuxInDrv *drv = new MuxInDrv(dut);
    MuxInMon *inMon = new MuxInMon(dut, scb);
    MuxOutMon *outMon = new MuxOutMon(dut, scb);

    while (sim_time < MAX_SIM_TIME) {
        dut->clk = 0;
        dut->eval();
        dut->clk = 1;
        dut->eval();

        if(sim_time >= VERIF_START_TIME){
            // Monitor input interface
            inMon->monitor();

            // Drive random transactions
            tx = rndMuxInTx();
            drv->drive(tx);

            // Monitor output interface
            outMon->monitor();
        }

        m_trace->dump(sim_time);
        sim_time++;
    }

    m_trace->close();
    delete dut;
    delete scb;
    delete drv;
    delete inMon;
    delete outMon;
    exit(EXIT_SUCCESS);
}
