#include <verilated.h>
#include <verilated_vcd_c.h>
#include "Vcpu.h"

// Verilator Example
// Generated by ChatGPT 2024

#include <stdlib.h>
#include <iostream>
#include <cstdlib>
#include <deque>
#include <memory>

#define MAX_SIM_TIME 300
#define VERIF_START_TIME 7
vluint64_t sim_time = 0;

// ALU input interface transaction item class
class CpuInTx {
    public:
        uint16_t run;
        uint8_t reset;
        uint8_t carry_in;
};

// ALU output interface transaction item class
class CpuOutTx {
    public:
        uint8_t mux_sel;
        uint8_t done;
        uint8_t d_out;
        uint8_t sel;
        uint8_t mode;
        uint8_t en_s;
        uint8_t en_c;
        uint8_t en;
        uint8_t en_inst;
        uint8_t compare;
        uint8_t carry_out;
};

// ALU scoreboard
class CpuScb {
    private:
        std::deque<CpuInTx*> in_q;

    public:
        void writeIn(CpuInTx *tx){
            in_q.push_back(tx);
        }

        void writeOut(CpuOutTx* tx){
            if(in_q.empty()){
                std::cout <<"Fatal Error in CpuScb: empty CpuInTx queue" << std::endl;
                exit(1);
            }

            CpuInTx* in = in_q.front();
            in_q.pop_front();

            // Expected result calculation
            uint16_t expected_alu_out = 0;
            uint8_t expected_carry_out = 0;
            uint8_t expected_compare = (in->a == in->b) ? 1 : 0;

            if (in->mode == 1) { // Logic operations
                switch (in->select) {

                }
                }


            // Compare expected and actual results
            if (expected_alu_out != tx->alu_out || expected_carry_out != tx->carry_out || expected_compare != tx->compare) {
                std::cout << "CpuScb mismatch:" << std::endl;
                std::cout << "  Expected: a: " <<in->a << ", b: " << in->b << ", ALU Out = " << expected_alu_out << ", Carry Out = " << (int)expected_carry_out << ", Compare = " << (int)expected_compare << std::endl;
                std::cout << "  Actual: ALU Out = " << tx->alu_out << ", Carry Out = " << (int)tx->carry_out << ", Compare = " << (int)tx->compare << std::endl;
                std::cout << "  Simtime: " << sim_time << std::endl;
                std::cout << "  Select: " << (int)in->select << std::endl;
                std:: cout<< "  Mode: " <<(int) in->mode<< std:: endl;
                
                
            }

            delete in;
            delete tx;
        }
};

// ALU input interface driver
class CpuInDrv {
    private:
        Vcpu *dut;
    public:
        CpuInDrv(Vcpu *dut){
            this->dut = dut;
        }

        void drive(CpuInTx *tx){
            if(tx != NULL){
                dut->carry_in = tx->carry_in;
                dut->run = tx->run;
                dut->reset = tx->reset;
                delete tx;
            }
        }
};

// ALU input interface monitor
class CpuInMon {
    private:
        Vcpu *dut;
        CpuScb *scb;
    public:
        CpuInMon(Vcpu *dut, CpuScb *scb){
            this->dut = dut;
            this->scb = scb;
        }

        void monitor(){
            CpuInTx *tx = new CpuInTx();
            tx->carry_in = dut->carry_in;
            tx->run = dut->run;
            tx->reset = dut->reset;
            scb->writeIn(tx);
        }
};

// ALU output interface monitor
class CpuOutMon {
    private:
        Vcpu *dut;
        CpuScb *scb;
    public:
        CpuOutMon(Vcpu *dut, CpuScb *scb){
            this->dut = dut;
            this->scb = scb;
        }

        void monitor(){
            CpuOutTx *tx = new CpuOutTx();
            tx->carry_out = dut->carry_out;
            tx->mux_sel = dut->mux_sel;
            tx->done = dut->done;
            tx->d_out= dut->d_out;
            tx->sel = dut->sel;
            tx->mode = dut->mode;
            tx->en_s = dut->en_s;
            tx->en_c = dut->en_c;
            tx->en = dut->en;
            tx->en_inst = dut->en_inst;
            tx->compare = dut->compare;
            scb->writeOut(tx);
        }
};

// ALU random transaction generator
CpuInTx* rndCpuInTx(){
    if(rand() % 5 == 0){
        CpuInTx *tx = new CpuInTx();
        tx->run = rand() % 65536;
        tx->mode = rand() % 2;
        tx->carry_in = rand() % 2;
        return tx;
    } else {
        return NULL;
    }
}

int main(int argc, char** argv, char** env) {
    srand(time(NULL));
    Verilated::commandArgs(argc, argv);
    Vcpu *dut = new Vcpu;

    Verilated::traceEverOn(true);
    VerilatedVcdC *m_trace = new VerilatedVcdC;
    dut->trace(m_trace, 5);
    m_trace->open("waveform.vcd");

    CpuInTx *tx;

    CpuScb *scb = new CpuScb();
    CpuInDrv *drv = new CpuInDrv(dut);
    CpuInMon *inMon = new CpuInMon(dut, scb);
    CpuOutMon *outMon = new CpuOutMon(dut, scb);

    while (sim_time < MAX_SIM_TIME) {
        dut->eval();

        if(sim_time >= VERIF_START_TIME){
            // Monitor input interface
            inMon->monitor();

            // Drive random transactions
            tx = rndCpuInTx();
            drv->drive(tx);

            // Monitor output interface
            outMon->monitor();
        }

        m_trace->dump(sim_time);
        sim_time++;
    }

    m_trace->close();
    delete dut;
    delete scb;
    delete drv;
    delete inMon;
    delete outMon;
    exit(EXIT_SUCCESS);
}
